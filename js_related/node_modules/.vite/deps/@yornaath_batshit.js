import "./chunk-RT7CDYDI.js";

// ../../../../AppData/Local/Yarn/Berry/cache/@yornaath-batshit-npm-0.10.1-c034b55ef0-10c0.zip/node_modules/@yornaath/batshit/dist/deferred.mjs
var deferred = () => {
  let resolve;
  let reject;
  const value = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return {
    resolve,
    reject,
    value
  };
};

// ../../../../AppData/Local/Yarn/Berry/cache/@yornaath-batshit-npm-0.10.1-c034b55ef0-10c0.zip/node_modules/@yornaath/batshit/dist/index.mjs
var create = (config, memory) => {
  var _a;
  const name = config.name ?? `batcher:${Math.random().toString(16).slice(2)})`;
  const scheduler = config.scheduler ?? windowScheduler(10);
  const devtools = (_a = globalThis.__BATSHIT_DEVTOOLS__) == null ? void 0 : _a.for(name);
  let mem = memory ?? {
    seq: 0,
    batch: /* @__PURE__ */ new Set(),
    currentRequest: deferred(),
    timer: void 0,
    start: null,
    latest: null
  };
  devtools == null ? void 0 : devtools.create({ seq: mem.seq });
  const nextBatch = () => {
    mem.batch = /* @__PURE__ */ new Set();
    mem.currentRequest = deferred();
    mem.timer = void 0;
    mem.start = null;
    mem.latest = null;
  };
  const fetch = (query) => {
    if (!mem.start)
      mem.start = Date.now();
    mem.latest = Date.now();
    mem.batch.add(query);
    clearTimeout(mem.timer);
    const scheduled = scheduler(mem.start, mem.latest, mem.batch.size);
    devtools == null ? void 0 : devtools.queue({
      seq: mem.seq,
      query,
      batch: [...mem.batch],
      scheduled,
      latest: mem.latest,
      start: mem.start
    });
    const fetchBatch = () => {
      const currentSeq = mem.seq;
      const req = config.fetcher([...mem.batch]);
      const currentRequest = mem.currentRequest;
      devtools == null ? void 0 : devtools.fetch({ seq: currentSeq, batch: [...mem.batch] });
      nextBatch();
      req.then((data) => {
        devtools == null ? void 0 : devtools.data({ seq: currentSeq, data });
        currentRequest.resolve(data);
      }).catch((error) => {
        devtools == null ? void 0 : devtools.error({ seq: currentSeq, error });
        currentRequest.reject(error);
      });
      mem.seq++;
      return req;
    };
    if (scheduled === "immediate") {
      const req = mem.currentRequest;
      fetchBatch();
      return req.value.then((items) => config.resolver(items, query));
    } else if (scheduled === "never") {
      return mem.currentRequest.value.then((items) => config.resolver(items, query));
    } else {
      mem.timer = setTimeout(fetchBatch, scheduled);
      return mem.currentRequest.value.then((items) => config.resolver(items, query));
    }
  };
  return { fetch };
};
var keyResolver = (key) => (items, query) => items.find((item) => item[key] == query) ?? null;
var indexedResolver = () => (itemsIndex, query) => itemsIndex[query] ?? null;
var windowScheduler = (ms) => (start, latest) => {
  const spent = latest - start;
  return ms - spent;
};
var bufferScheduler = (ms) => () => {
  return ms;
};
var windowedFiniteBatchScheduler = ({ windowMs, maxBatchSize }) => (start, latest, batchSize) => {
  if (batchSize >= maxBatchSize)
    return "immediate";
  const spent = latest - start;
  return windowMs - spent;
};
var maxBatchSizeScheduler = ({ maxBatchSize }) => (_start, _latest, batchSize) => {
  if (batchSize >= maxBatchSize)
    return "immediate";
  return "never";
};
export {
  bufferScheduler,
  create,
  indexedResolver,
  keyResolver,
  maxBatchSizeScheduler,
  windowScheduler,
  windowedFiniteBatchScheduler
};
//# sourceMappingURL=@yornaath_batshit.js.map
